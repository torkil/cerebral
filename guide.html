<html>
<head>

  <title></title>

  <link rel="stylesheet" type="text/css" href="style/main.css">
  <link rel="stylesheet" type="text/css" href="style/github-highlight.css">

  

  <script type="text/javascript" src="./js/rainbow.js"></script>
  <script type="text/javascript" src="./js/languages/generic.js"></script>
  <script type="text/javascript" src="./js/languages/html.js"></script>
  <script type="text/javascript" src="./js/languages/javascript.js"></script>

  <script type="text/javascript">

    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-33922998-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();

  </script>

  <script type="text/javascript">
    (function() {
      var fadedIn
      window.addEventListener("scroll", function() {
        if(!fadedIn && window.pageYOffset > 50) {
          var header = document.getElementsByTagName('header')[0]
          header.className = 'bordered'
          fadedIn = true
        } else if( window.pageYOffset < 50 ) {
          var header = document.getElementsByTagName('header')[0]
          header.className = ''
          fadedIn = false
        }
      })
    })()
    
  </script>

</head>
<body>

  <header>
    <h1>cerebral.js</h1>
    <nav>
      <ul>
        <li class="end"><a href="https://github.com/gorillatron/cerebral">github</a></li>
        <li>API Reference</li>
        <li class="active">Guide</li>
        <li> <a href="./index.html">Home</a></li>
      </ul>
    </nav>
  </header>

  

  <section id="content" class="guide">

    <section id="preface">
      <h1>Requirements and dependencies</h1>
      <p>
        Cerebral depends on and utelizes the following libraries; 
        <a class="tag" href="http://requirejs.org/">requirejs</a>, 
        <a class="tag" href="http://backbonejs.org/">backbone</a>, 
        <a class="tag" href="http://documentcloud.github.com/underscore/">underscore</a> or <a class="tag" href="http://lodash.com/">lo-dash</a> and 
        <a class="tag" href="http://jquery.com/">jQuery</a>.
      </p>
      <p>
        For now these are requirements. In future development we will try to make it work with a more lightweight module loader like almond, 
        and be DOM library agnostic so you can use zepto, ender or any other library of choice for DOM manipulation.
      </p>

      <h3>Disclaimer</h3>
      <p>
        Understanding of backbone and amd loaders like requirejs needed.
      </p>
      <p>
        All APIs er subject to change.
      </p>
    </section>

    <section id="getting-started">
      <h1>Getting started</h1>
      <p>
        First we set up requirejs so cerebral knows where to look for backbone, underscore and jquery.
      </p>
<pre>
<code data-language="html">
  &lt;script type="text/javascript" src="cerebral/vendor/require.js"></script>

  &lt;script type="text/javascript">
      require.config({
        baseUrl: "js/",
        shim: {
          "backbone": {
            deps: ["underscore", "jquery"],
            exports: "Backbone"
          },
          "underscore": {
            exports: "_"
          },
        },
        paths: {
          "backbone": "cerebral/vendor/backbone",
          "underscore": "cerebral/vendor/underscore",
          "jquery": "cerebral/vendor/jquery"
        }
      })
  &lt;/script>
</code>
</pre>
    
    <h2>Setting up the app</h2>
    <p>
      Now we include the main javascript file of our application, this will use the cerebral/application/core to load its modules.
    </p>

<pre>
<code data-language="html">
  &lt;script type="text/javascript" src="js/app.js"></script>
</code>
</pre>
    
      <h3>app.js</h3>
      <p>
        This is the main executable javascript file of your application. You dont have to name it app offcourse. This is where we require the core, set up the app,
        configure it and start some modules.
      </p>

<pre>
<code data-language="js">
require([ "cerebral/application/core" ], function( core ){
  
  var app = Object.create( core )

  app.configure({
    moduleRoot: 'modules/'
  })

  app.start("chat", {
    sandbox: {
      element: '#chat'
    }
  })

  app.start("log", {
    sandbox: {
      element: '#log'
    }
  })

})
</code>
</pre>
      
      <h4>core.configure</h4>
      <p>
        This method configures the core, the most important for now is the 'moduleRoot' property, this tells the app where its modules are located so it can load them and
        start them up.
      </p>

      <p>Here is an example of how the path for a module is resolved:</p>
<pre>
<code data-language="js">

require.config({ baseUrl: 'js/' })

core.configure({ moduleRoot: 'modules/' })

core.start( 'chat' ) // -> js/modules/chat/main.js

</code>
</pre>
      
      <h4>core.start</h4>
      <p>
        It will use requirejs to load the modules main file and check that it either returns a function or an object containing a main method. Here is and example
        of a module main file.
      </p>
<pre>
<code data-language="js">
//chat/main.js

define("modules/chat",[ 
  "chat/sandbox" 
], 
function( sandbox ) {
  
  function main() {
    console.log( "started chat" )
  }

  return main
})
</code>
</pre>

      <p>
        You might allso notice that when we started our modules we gave an object as our second parameter containing a element with a string css selector as a value. This will be used to
        tell the modules sandbox what element on the pace it has access to.
      </p>

      <h3>Modules</h3>
      <p>
        A module consists of a main.js file and any other javacript, html or css files it needs. It can also have its own sub modules( <i>folders</i> ), but they will not be treated as a application module (<i>can be started and stopped via the core</i> ).
      </p>

      <p>
        There are several ways to define your modules main method, and also a destruct method.
      </p>

      <p>
        Using an object is the prefered way. This ensures that you can refer to the module as 'this' within its methods.
      </p>

<pre>
<code data-language="js">
// somemodules/main.js

return {
  main: function(){ ... },
  destruct: function( done ){ ... }
}
</code>
</pre>

<p>
  Using a function:<br>
  <b class="caution">caution:</b> This is not recomended if you refer to the module itself as 'this' within one of its methods.
</p>

<pre>
<code data-language="js">
// somemodules/main.js

return function main(){ ... }

// or

function main(){ ... }

main.destruct = function( done ){ ... }

return main
</code>
</pre>
      
      
      
      <h4>destruct</h4>
      <p>
        The 'done' parameter sent to destruct is meant to be called when you are done destructing your module. It must allways be called to be sure the module
        is properly stopped and unloaded. But is handy when you want to do asynchronous things like wait for an animation to finish or an ajax call to return before
        unloading.
      </p>

<pre>
<code data-language="js">
// somemodules/main.js

return {
  main: function(){ ... },
  destruct: function( done ){ 

    view.$el.fadeOut( 300, done )

  }
}
</code>
</pre>

      <h2>Sandbox</h2>
      <p>
        When the chat module is loaded it is defined a namespace using requirejs where the chat modules sandbox is located. This sandbox will contain the element the module is assigned,
        a scoped jQuery/DOM manipulation function that only has access to elements within the module element and other properties you specify on the sandboxfactory.
      </p>

<pre>
<code data-language="js">
//chat/main.js

define("modules/chat",[ 
  "chat/sandbox" 
], 
function( sandbox ) {

  function main() {
    
    sandbox.element[ 0 ] === $('#chat')[ 0 ] 
    true

    sandbox.$( '#other-module' ).length === 0   
    true

  }
  ...
</code>
</pre>
      
      <h3>pub-sub</h3>
      <p>
        The sandbox is delegated safe to use methods from the core for subscribing and publishing events. This is the only way modules should communicate with each other.
        However you can overide this if needed.
      </p>

      <h4>subscribing to events</h4>
      <p>
        Subscribing sets a callback to fire when that channel gets published to, passing published parameters to the callback.
      </p>
<pre>
<code data-language="js">
//log/main.js

usercount = 0

sandbox.subscribe( "chat.userenter", function( user ){ usercount++ } )
sandbox.subscribe( "chat.userleave", function( user ){ usercount-- } )
</code>
</pre>

<h4>publishing events</h4>
<p>
  Publishing to a channel will fire all the callbacks for that channel, passing arguments after channelname to the callbacks ar arguments.
</p>
<pre>
<code data-language="js">
//chat/main.js

sandbox.publish( "chat.userenter", user )
sandbox.publish( "chat.userleave", user )
</code>
</pre>


      <h3>Cutomizing the sandbox</h3>
      <p>
        The philosophy behind the sandbox is giving your modules a defined environment to work in. Where additional functionality is added only one place
        and underlying mechanics can easily be swapped, but the interface stay intact.
      </p>

      <p>
        The property 'sandboxprototype' of the sandboxfactory is the object that every created sandbox will have as its prototype. By modifying it you modify the
        functionality of all created sandboxes.
      </p>

<pre>
<code data-language="js">
require([ "cerebral/application/core", "cerebral/application/sandboxfactory" ], function( core, sandboxfactory ){
  
  sandboxfactory.sandboxprototype.log = function( msg ) {
    if( window.console && console.log )
      console.log( msg )
    else
      alert( msg )
  }

  var app = Object.create( core )
  app.configure({...
</code>
</pre>
      
      <h4>Individual sandboxes</h4>
      <p>
        You can give individual modules specific sandboxes by either sending an object with attributes as sandbox value to 'core.start' or you can create one with the sandboxfactory
        and send it as sandbox.
      </p>

<pre>
<code data-language="js">
sandbox = sandboxfactory.create({ ... })

core.start('module', {
  sandbox: sandbox
})

</code>
</pre>

      <p>
        Or passing an object:
      </p>

<pre>
<code data-language="js">
core.start('module', {
  sandbox: { ... }
})

</code>
</pre>

      <h4>Shared sandboxes</h4>
      <p>
        By creating and sending a sandbox reference directly the sandbox can be shared accross modules.
      </p>

<pre>
<code data-language="js">
sharedSandbox = sandboxfactory.create({ ... })

core.start('module', {
  sandbox: sharedSandbox
})

core.start('another-module', {
  sandbox: sharedSandbox
})

</code>
</pre>

    </section>

  </section>




  <footer>
    <div class="credits">
      Built by Andre Tangen <span class="gorillatron"><a href="https://twitter.com/gorillatron">@gorillatron</a></span> and <span class="wtw"><img src="style/gfx/wtw3.png"></span>
    </div>
  </footer>

</body>
</html>